ğŸ¯ OBJECTIF (FRONT UNIQUEMENT â€” NE PAS TOUCHER AU BACK)
Corriger lâ€™erreur front affichÃ©e (â€œOups ! Une erreur sâ€™est produiteâ€) en rendant la page de rÃ©servation tolÃ©rante :
- fetch sÃ©curisÃ© avec timeout + gestion dâ€™erreur claire,
- normalisation de la rÃ©ponse API (valeurs par dÃ©faut si champs manquants),
- redirection automatique vers le slug valide si le backend renvoie un salon diffÃ©rent (fallback),
- composants de repli (ErrorBoundary + panneau de rÃ©essai),
- SANS modifier le serveur ni les configs dÃ©jÃ  en place.

SCOPE : **NE MODIFIER QUE `client/**`**
- Interdit de modifier `server/**`, `tsconfig.base.json`, `.eslintrc.cjs`, `.prettierrc`, `drizzle.config.ts`, etc.
- On corrige exclusivement le code de la page de rÃ©servation et lâ€™accÃ¨s API cÃ´tÃ© client.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1) LIBS FRONT : FETCH SÃ‰CURISÃ‰ + TYPES
CrÃ©er/Ã©craser `client/src/types.ts` :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export type Salon = {
  id: string;          // peut servir de slug
  name: string;
  description?: string | null;
  address?: string | null;
};

export type Service = {
  id: string;
  salonId: string;
  name: string;
  price: number;
};

export type ApiError = { message: string; status?: number };
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

CrÃ©er/Ã©craser `client/src/lib/safeFetch.ts` :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export class HttpError extends Error {
  status?: number;
  constructor(message: string, status?: number) {
    super(message);
    this.name = 'HttpError';
    this.status = status;
  }
}

// fetch avec timeout + parse JSON + erreurs propres
export async function safeFetch<T>(
  url: string,
  init?: RequestInit,
  timeoutMs = 15000
): Promise<T> {
  const ctrl = new AbortController();
  const id = setTimeout(() => ctrl.abort(), timeoutMs);
  try {
    const res = await fetch(url, { ...init, signal: ctrl.signal });
    const ct = res.headers.get('content-type') || '';
    const isJson = ct.includes('application/json');

    if (!res.ok) {
      const msg = isJson ? (await res.json())?.error ?? res.statusText : res.statusText;
      throw new HttpError(
        typeof msg === 'string' ? msg : JSON.stringify(msg),
        res.status
      );
    }

    return (isJson ? await res.json() : (null as any)) as T;
  } catch (e: any) {
    if (e?.name === 'AbortError') {
      throw new HttpError('Timeout rÃ©seau', 408);
    }
    if (e instanceof HttpError) throw e;
    throw new HttpError(e?.message ?? 'Erreur rÃ©seau');
  } finally {
    clearTimeout(id);
  }
}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

CrÃ©er/Ã©craser `client/src/lib/api.ts` :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
import { safeFetch } from './safeFetch';
import type { Salon, Service } from '../types';

const BASE = import.meta.env.VITE_API_URL?.replace(/\/+$/, '') ?? '';

function assertBase() {
  if (!BASE) {
    // on lÃ¨ve une erreur claire pour Ã©viter les plantages silencieux
    throw new Error('VITE_API_URL manquant cÃ´tÃ© client');
  }
}

export async function getSalonResolvedBySlug(slugOrId: string): Promise<Salon> {
  assertBase();
  // cÃ´tÃ© serveur, /api/v1/salons/:id renvoie le salon correspondant ou le salon par dÃ©faut (fallback)
  const data = await safeFetch<Salon>(`${BASE}/api/v1/salons/${encodeURIComponent(slugOrId)}`);
  // Normalisation minimale
  return {
    id: String((data as any)?.id ?? 'salon-default'),
    name: String((data as any)?.name ?? 'Salon DÃ©mo'),
    description: (data as any)?.description ?? null,
    address: (data as any)?.address ?? null,
  };
}

export async function getServicesForSalon(salonId: string): Promise<Service[]> {
  assertBase();
  const list = await safeFetch<any[]>(`${BASE}/api/v1/services?salonId=${encodeURIComponent(salonId)}`);
  return Array.isArray(list)
    ? list.map((s) => ({
        id: String(s?.id ?? crypto.randomUUID()),
        salonId: String(s?.salonId ?? salonId),
        name: String(s?.name ?? 'Service'),
        price: Number.isFinite(+s?.price) ? +s.price : 0,
      }))
    : [];
}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2) GARDES Dâ€™ERREUR UI (MATCH Lâ€™Ã‰CRAN QUE TU VOIS)
CrÃ©er/Ã©craser `client/src/components/ErrorBoundary.tsx` :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
import { Component, ReactNode } from 'react';

type Props = { children: ReactNode };
type State = { hasError: boolean; error?: any };

export class ErrorBoundary extends Component<Props, State> {
  state: State = { hasError: false };

  static getDerivedStateFromError(error: any): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: any, errorInfo: any) {
    if (import.meta.env.DEV) {
      // eslint-disable-next-line no-console
      console.error('[ErrorBoundary]', error, errorInfo);
    }
  }

  render() {
    if (this.state.hasError) {
      return (
        <div style={{ maxWidth: 520, margin: '48px auto', padding: 24, background: '#fff', borderRadius: 12, boxShadow: '0 8px 30px rgba(0,0,0,.08)', textAlign: 'center' }}>
          <div style={{ fontSize: 18, fontWeight: 700, marginBottom: 8 }}>Oups ! Une erreur s'est produite</div>
          <p style={{ color: '#444', marginBottom: 16 }}>
            Nous avons rencontrÃ© un problÃ¨me inattendu. RÃ©essaie.
          </p>
          <button onClick={() => location.reload()} style={{ padding: '10px 16px', borderRadius: 8, border: 'none', background: '#6c4df6', color: '#fff', cursor: 'pointer' }}>
            RÃ©essayer
          </button>
          <details style={{ marginTop: 12, color: '#666' }}>
            <summary>DÃ©tails techniques (dÃ©veloppement uniquement)</summary>
            <pre style={{ textAlign: 'left', overflowX: 'auto' }}>{String(this.state.error?.stack ?? this.state.error ?? '')}</pre>
          </details>
        </div>
      );
    }
    return this.props.children;
  }
}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

CrÃ©er/Ã©craser `client/src/components/RetryPanel.tsx` :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
type Props = { onRetry?: () => void; message?: string };
export function RetryPanel({ onRetry, message }: Props) {
  return (
    <div style={{ maxWidth: 520, margin: '48px auto', padding: 24, background: '#fff', borderRadius: 12, boxShadow: '0 8px 30px rgba(0,0,0,.08)', textAlign: 'center' }}>
      <div style={{ fontSize: 18, fontWeight: 700, marginBottom: 8 }}>Oups ! Une erreur s'est produite</div>
      <p style={{ color: '#444', marginBottom: 16 }}>
        {message ?? "Nous avons rencontrÃ© un problÃ¨me inattendu. L'Ã©quipe technique a Ã©tÃ© notifiÃ©e."}
      </p>
      <button onClick={onRetry} style={{ padding: '10px 16px', borderRadius: 8, border: 'none', background: '#6c4df6', color: '#fff', cursor: 'pointer' }}>
        RÃ©essayer
      </button>
    </div>
  );
}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
3) HOOK DE CHARGEMENT SALON + REDIRECTION SI SLUG INVALIDE
CrÃ©er/Ã©craser `client/src/hooks/useSalonLoader.ts` :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
import { useCallback, useEffect, useMemo, useState } from 'react';
import { getSalonResolvedBySlug, getServicesForSalon } from '../lib/api';
import type { Salon, Service } from '../types';

function extractSlugFromPath(): string | undefined {
  // essaie de trouver un segment /salon-booking/:slug ou dernier segment non vide
  const path = location.pathname.replace(/\/+$/, '');
  const parts = path.split('/').filter(Boolean);
  const idx = Math.max(parts.lastIndexOf('salon-booking'), parts.lastIndexOf('booking'));
  if (idx >= 0 && parts[idx + 1]) return parts[idx + 1];
  return parts[parts.length - 1];
}

export function useSalonLoader() {
  const requestedSlug = useMemo(() => extractSlugFromPath(), []);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [salon, setSalon] = useState<Salon | null>(null);
  const [services, setServices] = useState<Service[]>([]);

  const load = useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      const s = await getSalonResolvedBySlug(requestedSlug ?? 'salon-default');
      // si le backend a rÃ©solu un autre salon (fallback), rediriger vers l'ID canonique
      if (requestedSlug && s.id && requestedSlug !== s.id) {
        const url = location.pathname.replace(requestedSlug, s.id);
        history.replaceState(null, '', url + location.search);
      }
      setSalon(s);
      const svc = await getServicesForSalon(s.id);
      setServices(svc);
    } catch (e: any) {
      setError(e?.message ?? 'Erreur');
    } finally {
      setLoading(false);
    }
  }, [requestedSlug]);

  useEffect(() => { load(); }, [load]);

  return { loading, error, salon, services, retry: load };
}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
4) PAGE DE RÃ‰SERVATION : INTÃ‰GRATION SANS CASSER Lâ€™EXISTANT
â†’ Trouver le composant/page qui affiche la rÃ©servation (nom probable : `SalonBooking`, `BookingPage`, `Reservation`, etc.).  
â†’ Sâ€™il existe dÃ©jÃ , NE PAS rÃ©Ã©crire la UI : **envelopper** son contenu avec la logique ci-dessous.  
â†’ Sinon, crÃ©er un nouveau composant `client/src/pages/SalonBookingPage.tsx` et lâ€™utiliser dans la route existante.

CrÃ©er/Ã©craser `client/src/pages/SalonBookingPage.tsx` :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
import { ErrorBoundary } from '../components/ErrorBoundary';
import { RetryPanel } from '../components/RetryPanel';
import { useSalonLoader } from '../hooks/useSalonLoader';

export default function SalonBookingPage() {
  const { loading, error, salon, services, retry } = useSalonLoader();

  if (loading) return <div style={{ padding: 24 }}>Chargementâ€¦</div>;
  if (error) return <RetryPanel onRetry={retry} message={error} />;
  if (!salon) return <RetryPanel onRetry={retry} message="Salon introuvable (fallback non disponible)" />;

  // âš ï¸ ICI : NE PAS casser la UI existante.
  // Si tu as dÃ©jÃ  un composant de rendu (ex: <BookingFlow salon={salon} services={services}/>),
  // monte-le Ã  la place du placeholder ci-dessous.
  return (
    <ErrorBoundary>
      <div style={{ padding: 24 }}>
        <h1>{salon.name}</h1>
        <p style={{ color: '#666' }}>{salon.address ?? 'Adresse non renseignÃ©e'}</p>
        <h3 style={{ marginTop: 16 }}>Services</h3>
        <ul>
          {services.length ? services.map(s => (
            <li key={s.id}>{s.name} â€” {s.price} â‚¬</li>
          )) : <li>Aucun service disponible pour le moment.</li>}
        </ul>
      </div>
    </ErrorBoundary>
  );
}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ğŸ”§ IntÃ©gration :
- Rechercher la route qui rend actuellement la page de rÃ©servation (fichiers contenant `salon-booking` ou `booking` dans `client/src`).
- Remplacer le composant rendu par dÃ©faut par `SalonBookingPage` (sans supprimer les anciens composants mÃ©tiers ; on les rÃ©utilise si besoin Ã  lâ€™intÃ©rieur).
- NE PAS supprimer les styles ou la navigation existants.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
5) FILETS DE SÃ‰CURITÃ‰ GLOBAUX
- VÃ©rifier que `VITE_API_URL` est bien dÃ©fini (sinon `api.ts` lÃ¨ve une erreur claire).
- En DEV, laisser `console.error` ; en PROD, ne pas spammer.
- Sâ€™assurer que tous les appels rÃ©seau de la page de rÃ©servation passent par `safeFetch` (remplacer les fetch bruts locaux Ã  ce scope, pas ailleurs).

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
6) TESTS MANUELS RAPIDES
1. Ouvrir `/salon-booking/<un-slug-qui-n-existe-pas>`
   - Attendu : **pas** dâ€™Ã©cran dâ€™erreur fatal ; UI sâ€™affiche
   - Lâ€™URL se remplace automatiquement par `/salon-booking/salon-default` (ou par lâ€™ID rÃ©el renvoyÃ©)
2. Ouvrir `/salon-booking/salon-default`
   - Attendu : chargement OK ; liste de services (Ã©ventuellement 1 service par dÃ©faut)
3. Simuler une panne rÃ©seau (couper le serveur)
   - Attendu : panneau â€œRÃ©essayerâ€ avec bouton qui relance lâ€™appel quand le serveur revient

âœ… Si ces 3 checks passent, lâ€™erreur â€œOups ! Une erreur sâ€™est produiteâ€ ne rÃ©apparaÃ®tra plus sur ce flux.
