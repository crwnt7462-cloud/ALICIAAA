ğŸ¯ OBJECTIF
Ã‰radiquer â€œSalon not foundâ€ sur TOUT le parcours :
- Seed auto dâ€™un salon & service par dÃ©faut si DB vide
- Fallback `salon-default` sur TOUTES les routes dÃ©pendantes du salon
- Endpoints services & salons tolÃ©rants (dev/staging), stricts en prod si tu le dÃ©cides

PRÃ‰-REQUIS
- Le prompt prÃ©cÃ©dent (seed + /bookings avec fallback) est dÃ©jÃ  appliquÃ©
- Stack: Supabase + Neon + Drizzle
- SchÃ©ma dans server/src/schema.ts contient: salons, services, bookings

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1) AJOUTER OUTILS COMMUNS (fallback salon) 
CrÃ©er/Ã©craser `server/src/utils/salon.ts` :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
import { db } from '../db';
import { salons, services } from '../schema';
import { eq } from 'drizzle-orm';
import { DEFAULT_SALON_ID, DEFAULT_SERVICE_ID } from '../seed';

export async function ensureDefaultSalonExists() {
  const rows = await db.select().from(salons).where(eq(salons.id, DEFAULT_SALON_ID)).limit(1);
  if (rows.length === 0) {
    await db.insert(salons).values({
      id: DEFAULT_SALON_ID,
      name: 'Salon DÃ©mo',
      description: 'Salon crÃ©Ã© automatiquement (fallback)',
      address: 'Paris',
    });
  }
  const svc = await db.select().from(services).where(eq(services.id, DEFAULT_SERVICE_ID)).limit(1);
  if (svc.length === 0) {
    await db.insert(services).values({
      id: DEFAULT_SERVICE_ID,
      salonId: DEFAULT_SALON_ID,
      name: 'Coupe simple',
      price: 20,
    });
  }
}

export async function resolveSalonIdOrDefault(salonId?: string) {
  const wanted = salonId ?? DEFAULT_SALON_ID;
  const rows = await db.select().from(salons).where(eq(salons.id, wanted)).limit(1);
  if (rows.length > 0) return wanted;
  // sinon fallback
  const def = await db.select().from(salons).where(eq(salons.id, DEFAULT_SALON_ID)).limit(1);
  if (def.length === 0) {
    // environnement corrompu -> on garantit l'existence
    await ensureDefaultSalonExists();
  }
  return DEFAULT_SALON_ID;
}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2) Ã‰TENDRE LES ROUTES V1 (salons & services + fallback)
Remplacer/mettre Ã  jour `server/src/routes/v1.ts` pour inclure ces routes :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
import { Router } from 'express';
import { z } from 'zod';
import { db } from '../db';
import { bookings, salons, services } from '../schema';
import { eq } from 'drizzle-orm';
import { DEFAULT_SALON_ID } from '../seed';
import { resolveSalonIdOrDefault } from '../utils/salon';

export const routerV1 = Router();

/** BOOKINGS (dÃ©jÃ  prÃ©sents dans le prompt prÃ©cÃ©dent, on les laisse en place) */
const createBookingSchema = z.object({
  userId: z.string().min(1),
  serviceId: z.string().min(1),
  date: z.string().datetime(),
  notes: z.string().optional(),
  salonId: z.string().min(1).optional()
});

routerV1.post('/bookings', async (req, res, next) => {
  const parsed = createBookingSchema.safeParse(req.body);
  if (!parsed.success) return res.status(400).json({ error: parsed.error.flatten() });

  try {
    const validSalonId = await resolveSalonIdOrDefault(parsed.data.salonId);
    const payload = {
      id: crypto.randomUUID(),
      userId: parsed.data.userId,
      serviceId: parsed.data.serviceId,
      date: new Date(parsed.data.date),
      notes: parsed.data.notes ?? undefined
    };
    await db.insert(bookings).values(payload);
    res.status(201).json({ booking: { ...payload, salonId: validSalonId } });
  } catch (err) {
    next(err);
  }
});

routerV1.get('/bookings/:id', async (req, res, next) => {
  try {
    const rows = await db.select().from(bookings).where(eq(bookings.id, req.params.id)).limit(1);
    if (!rows[0]) return res.status(404).json({ error: 'Not found' });
    res.json({ booking: rows[0] });
  } catch (err) {
    next(err);
  }
});

/** SALONS (ajouts) */
// GET /api/v1/salons -> liste, au moins le default
routerV1.get('/salons', async (_req, res, next) => {
  try {
    const rows = await db.select().from(salons);
    if (rows.length === 0) {
      // on garantit un minimum
      res.json([{ id: DEFAULT_SALON_ID, name: 'Salon DÃ©mo' }]);
      return;
    }
    res.json(rows);
  } catch (err) {
    next(err);
  }
});

// GET /api/v1/salons/:id -> dÃ©tail (fallback si inconnu en dev/staging)
routerV1.get('/salons/:id', async (req, res, next) => {
  try {
    const validSalonId = await resolveSalonIdOrDefault(req.params.id);
    const rows = await db.select().from(salons).where(eq(salons.id, validSalonId)).limit(1);
    if (!rows[0]) return res.status(404).json({ error: 'Not found' });
    res.json(rows[0]);
  } catch (err) {
    next(err);
  }
});

/** SERVICES (ajouts) */
// GET /api/v1/services?salonId=... -> liste des services du salon (fallback si salonId manquant/invalide)
routerV1.get('/services', async (req, res, next) => {
  try {
    const validSalonId = await resolveSalonIdOrDefault(
      typeof req.query.salonId === 'string' ? req.query.salonId : undefined
    );
    const rows = await db.select().from(services).where(eq(services.salonId, validSalonId));
    res.json(rows);
  } catch (err) {
    next(err);
  }
});

// GET /api/v1/services/salon/:salonId -> idem, via param
routerV1.get('/services/salon/:salonId', async (req, res, next) => {
  try {
    const validSalonId = await resolveSalonIdOrDefault(req.params.salonId);
    const rows = await db.select().from(services).where(eq(services.salonId, validSalonId));
    res.json(rows);
  } catch (err) {
    next(err);
  }
});
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
3) TESTS DE FUMÃ‰E SUPPLÃ‰MENTAIRES (services & salons)
CrÃ©er/Ã©craser `server/test/services-salons.test.ts` :
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
import { describe, it, expect } from 'vitest';
import request from 'supertest';

const baseURL = `http://localhost:${process.env.PORT ?? 3000}`;

describe('salons & services (fallback)', () => {
  it('GET /api/v1/salons should return at least default salon', async () => {
    const r = await request(baseURL).get('/api/v1/salons');
    expect(r.status).toBe(200);
    expect(Array.isArray(r.body)).toBe(true);
    expect(r.body.length).toBeGreaterThan(0);
  });

  it('GET /api/v1/salons/:id with unknown id should fallback to default and return 200', async () => {
    const r = await request(baseURL).get('/api/v1/salons/UNKNOWN_SALON');
    expect([200]).toContain(r.status);
    expect(r.body?.id).toBeDefined();
  });

  it('GET /api/v1/services without salonId should return default salon services', async () => {
    const r = await request(baseURL).get('/api/v1/services');
    expect(r.status).toBe(200);
    expect(Array.isArray(r.body)).toBe(true);
  });

  it('GET /api/v1/services?salonId=UNKNOWN should still return 200 via fallback', async () => {
    const r = await request(baseURL).get('/api/v1/services?salonId=UNKNOWN');
    expect(r.status).toBe(200);
  });

  it('GET /api/v1/services/salon/UNKNOWN should still return 200 via fallback', async () => {
    const r = await request(baseURL).get('/api/v1/services/salon/UNKNOWN');
    expect(r.status).toBe(200);
  });
});
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
4) RELANCE & VÃ‰RIFS
- RegÃ©nÃ©rer les migrations si le schÃ©ma a changÃ© depuis ta derniÃ¨re exÃ©cution :
  npx drizzle-kit generate
  # Appliquer la migration dans Neon/Supabase si besoin

- Relancer le serveur (le seed sâ€™assure que default salon/service existent) :
  npm --prefix server run dev

- ExÃ©cuter les tests :
  npm --prefix server test

âœ… RÃ©sultat attendu :
- `/api/v1/salons` rÃ©pond toujours avec au moins 1 salon (default)
- `/api/v1/services` rÃ©pond toujours (mÃªme sans salonId) avec les services du salon par dÃ©faut
- Les variantes avec salonId inconnu ne cassent plus (fallback â†’ 200)
- Le parcours de prise de RDV ne bloque plus sur â€œSalon not foundâ€
